# SKKU_ComputerGraphics_OceanGame
computer graphics OpenGL own 3D game


## 1. Playing Key
You can write the server IP by keyboard keypad or number in the first scene.

    F1 : Start the game as Server
    F2 : Start the game as Client
    KeyPad : Enter server IP address
    ↑, ↓ : play round up and down
    
  
In the second scene, you can play the game by using the next key.  

    W, A, S, D : move the ship  
    (Ctrl + ) 1, 3, 4, space : (Reinforce) Skill  
    F1, F2, F3, F4 : Skill information of 1,3,4,space  
    Left Mouse : Normal Attack 
    
    
## 2. How to play?

A player should destroy another's ship in playing time. Crash another player's ship, attack the ship, or use skills. 
You can eat the wood boards or barrels on the ocean. Wood board will recover your HP, and the barrel will increase your EXP.
If you have sufficient EXP, your level will be up. Then, you can get a skill point that makes your skill be advanced.

## 3. Techniques

### 1) Server-Client Programming

 It's a server-client 1vs1 PvP game. Therefore, we developed server game mode and client game mode. For the user's convenience, we made a game starter (/bin_execute/cgblur).
 The server client model diagram is like the following.
 
 ![1](https://user-images.githubusercontent.com/43103079/72053115-bd304180-3309-11ea-9b23-35df36f9b53d.png)

 
 
### 2) Water - Reflection, Refraction

 For reality, we implemented ocean using frame buffers. It needs to render 3 times like the next figure.
 
 ![2](https://user-images.githubusercontent.com/43103079/72053417-53646780-330a-11ea-8c55-816c931ec9be.png)
 
 The first time, we should take a reflection image by multiplying -1 on camera.eye.z as well as converting camera.at. In this time, only things which z is above 0 should be rendered by using glClipDistance. Then, the picture is taken to the Reflection Frame buffer.
 The second time, the Refraction framebuffer is similar to the reflection framebuffer. Just clip z which is above 0 to render only z<0. 
 Last, all models are rendered on the water texture rendered with mixing refraction framebuffer and reflection framebuffer finally.
 
 
 ### 3) Water - du,dv map
 
 To implement water flowing, our project used dudv map and a normal map. The dudv map is a 2-direction vector to represent texture coordinate distortion. Likewise, the normal map has a 3-direction value to represent a normal bump. Every point's normal vector value will change the normal value according to each 3-direction value.

 Below the figure is dudv map and a normal map.
 
 ![3](https://user-images.githubusercontent.com/43103079/72234129-df2e0a80-360e-11ea-9123-8f21aaf76c8c.png)

### 4) Fog system

 Visibility is calculated with formula : exp(-pow(distance * density, gradient)). The density and gradient are a constant which is defined at compile time. Distance is the length between each object and camera.
 
 Distance is calculated in the fragment shader, and visibility is calculated in the vertex shader. The lower visibility is, the gray color is.
 
The below figure shows the water and fog system.

![water](https://user-images.githubusercontent.com/43103079/73738137-3bf09100-4787-11ea-81ba-fa25f8f62bbc.png)


### 5) Terrain

 The terrain is generated by a height map which is bin/map/heightmap. The black color in the figure represents the lowest color. The blend map is used to blend the texture of the terrain. Each R,G,B value directly represents sand, stone, and snow texture. Then, 1-R-G-B value is grass texture. You can see the terrain also at the figure in 4).

![map](https://user-images.githubusercontent.com/43103079/73738334-a7d2f980-4787-11ea-9979-958b0847b7ba.png)


### 6) Particles

 We implement a flame thrower with a particles system. The particle system is implemented by glAttribPointer to send particles' position, and color data at once for high performance. In glsl, the layout is determined to get position and color data. The figure is below
 
 ![particle](https://user-images.githubusercontent.com/43103079/73739073-efa65080-4788-11ea-8543-4bb43d838d82.png)


### 7) Etc

 Other techniques are used but it is minor to explain here. Instead, I uploaded a PPT which I used in the project presentation. Please refer to it. There will be some typos and grammatical errors. I appreciate your patience.
